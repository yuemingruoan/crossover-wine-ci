[require]
shader model >= 4.0

[pixel shader]
float4 main() : SV_TARGET
{
    uint x = 5;
    uint y = 15;

    return float4(x + y, x - y, x * y, x / y);
}

[test]
draw quad
probe (0, 0) rgba (20.0, 4294967296.0, 75.0, 0.0)

[pixel shader]
float4 main() : SV_TARGET
{
    uint x = 5;
    uint y = 15;

    return float4(x % y, +x, -x, y / x);
}

[test]
draw quad
probe (0, 0) rgba (5.0, 5.0, 4294967296.0, 3.0)

[pixel shader fail(sm<6)]
float4 main() : SV_TARGET
{
    uint x = 1;
    uint y = 0;

    return x / y;
}

[test]
draw quad
probe (0, 0) rgba (0.0, 0.0, 0.0, 0.0)

[pixel shader fail(sm<6)]
float4 main() : SV_TARGET
{
    uint x = 1;
    uint y = 0;

    return x % y;
}

[test]
draw quad
probe (0, 0) rgba (0.0, 0.0, 0.0, 0.0)


% Test expression normalization and simplification.

[pixel shader]
uniform uint4 x;

float4 main() : SV_TARGET
{
    return 6 + (2 * x * 3) - 5;
}

[test]
uniform 0 uint4 0 1 2 3
draw quad
probe (0, 0) rgba (1.0, 7.0, 13.0, 19.0)

% Test collecting terms with constant coefficients.

[pixel shader]
uniform uint x;

float4 main() : SV_TARGET
{
    uint4 res;
    res.x = x * 2 + (3 + 3 * x);
    res.y = (x & 4) | (x & 1);
    res.z = max(min(2, x), min(x, 10));
    res.w = 0;
    return res;
}

[test]
uniform 0 uint 7
draw quad
probe (0, 0) rgba(38.0, 5.0, 7.0, 0.0)

[rtv 0]
format r32g32b32a32-uint
size (2d, 640, 480)

[pixel shader]
uniform uint4 c;

uint4 main() : SV_TARGET
{
    uint x = c.x & 0xffff;
    uint y = c.y & 0xffff;

    return uint4(x | (x << c.z), y | (c.z + y), (x >> c.w) ^ x, (c.w * y) ^ y);
}

[test]
uniform 0 uint4 0xccaa5533 7 1 2
draw quad
probe (0, 0) u32(0xff77, 0xf, 0x407f, 0x9)

% Minimum precision vectors in constant buffers have inconsistent behavior with
% SM6 (see minimum-precision.shader_test), so we're reading with arrays instead.

[pixel shader]
uniform min16uint u[2];

uint4 main() : sv_target
{
    min16uint i = 0xfff, j = 0x7ff;
    return uint4(u[0] + i, u[1] + j, 0, 0);
}

[test]
uniform 0 uint 0
uniform 4 uint 0
todo(msl & sm>=6) draw quad
probe (0, 0) u32(0xfff, 0x7ff, 0, 0)
uniform 0 uint 1
uniform 4 uint 0xfff
todo(msl & sm>=6) draw quad
probe (0, 0) u32(0x1000, 0x17fe, 0, 0)

[pixel shader]
uniform min16uint u[2];
uniform uint i;

uint4 main() : sv_target
{
    min16uint arr[4] = {1, 2, 0x7ff, 0xfff};
    return uint4(u[0] + arr[i], u[1] + arr[i + 1], 0, 0);
}

[test]
uniform 0 uint 2
uniform 4 uint 0xffe
% i is allocated differently between SM4-5 and SM6
uniform 5 uint 2
uniform 8 uint 2
todo(msl & sm>=6) draw quad
% In D3D12 with SM5 all reads to the array return 0
if(sm>=6 | !d3d12) probe (0, 0) u32(0x801, 0x1ffd, 0, 0)
uniform 0 uint 0
uniform 4 uint 0
uniform 5 uint 0
uniform 8 uint 0
todo(msl & sm>=6) draw quad
if(sm>=6 | !d3d12) probe (0, 0) u32(1, 2, 0, 0)

[pixel shader]
uniform min16uint u[4];

uint4 main() : sv_target
{
    min16uint i = 3, j = 5;
    return uint4(u[0] * i, u[1] * j, u[2] * i, u[3] * j);
}

[test]
uniform 0 uint 7
uniform 4 uint 9
uniform 8 uint 0xff9
uniform 12 uint 0xff7
todo(msl & sm>=6) draw quad
probe (0, 0) u32(21, 45, 0x2feb, 0x4fd3)

[pixel shader]
uniform min16uint u[4];

uint4 main() : sv_target
{
    min16uint i = 0xfff, j = 5;
    return uint4(u[0] / i, u[1] / j, u[2] / i, u[3] / j);
}

[test]
uniform 0 uint 0xfffe
uniform 4 uint 0xb
uniform 8 uint 0xffff
uniform 12 uint 0xffff
todo(msl | glsl) draw quad
probe (0, 0) u32(0x10, 2, 0x10, 0x3333)

[require]
shader model >= 6.2
native-16-bit

[pixel shader]
uniform uint16_t2 u;

uint4 main() : sv_target
{
    uint16_t i = 0x7fff, j = 0xffff;
    return uint4(u.x + i, u.y + j, 0, 0);
}

[test]
uniform 0 uint4 0 0 0 0
draw quad
probe (0, 0) u32(0x7fff, 0xffff, 0, 0)
uniform 0 uint4 0xffff0001 0 0 0
draw quad
probe (0, 0) u32(0x8000, 0xfffe, 0, 0)

[pixel shader]
uniform uint16_t4 u;
uniform uint i;

uint4 main() : sv_target
{
    uint16_t arr[4] = {1, 2, 0x7fff, 0xffff};
    return uint4(u.x + arr[i], u.y + arr[i + 1], 0, 0);
}

[test]
uniform 0 uint4 0xfffe0002 0 2 0
draw quad
probe (0, 0) u32(0x8001, 0xfffd, 0, 0)
uniform 0 uint4 0 0 0 0
draw quad
probe (0, 0) u32(1, 2, 0, 0)

[pixel shader]
uniform uint16_t4 u;

uint4 main() : sv_target
{
    uint16_t i = 3, j = 5;
    return uint4(u.x * i, u.y * j, u.z * i, u.w * j);
}

[test]
uniform 0 uint 0x90007
uniform 1 uint 0xfff7fff9
draw quad
probe (0, 0) u32(21, 45, 0xffeb, 0xffd3)

[pixel shader]
uniform uint16_t4 u;

uint4 main() : sv_target
{
    uint16_t i = 0xffff, j = 5;
    return uint4(u.x / i, u.y / j, u.z / i, u.w / j);
}

[test]
uniform 0 uint 0x000bfffe
uniform 1 uint 0xffffffff
draw quad
probe (0, 0) u32(0, 2, 1, 0x3333)

[require]
shader model >= 6.0
int64

[rtv 0]
format r32g32b32a32-float
size (2d, 640, 480)

[pixel shader]
uniform uint64_t2 a;

float4 main() : SV_TARGET
{
    uint64_t x = a.x;
    uint64_t y = a.y;
    return float4(x == y, y == x, x != y, y != x);
}

[test]
uniform 0 uint64_t2 42000000000 5000000000
draw quad
probe (0, 0) f32(0.0, 0.0, 1.0, 1.0)
uniform 0 uint64_t2 42000000000 42000000000
draw quad
probe (0, 0) f32(1.0, 1.0, 0.0, 0.0)

[pixel shader]
uniform uint64_t2 a;

float4 main() : SV_TARGET
{
    uint64_t x = a.x;
    uint64_t y = a.y;
    return float4(x <= y, y <= x, x >= y, y >= x);
}

[test]
uniform 0 uint64_t2 42000000000 5000000000
draw quad
probe (0, 0) f32(0.0, 1.0, 1.0, 0.0)
uniform 0 uint64_t2 42000000000 42000000000
draw quad
probe (0, 0) f32(1.0, 1.0, 1.0, 1.0)

[pixel shader]
uniform uint64_t2 a;

float4 main() : SV_TARGET
{
    uint64_t x = a.x;
    uint64_t y = a.y;
    return float4(x < y, y < x, x > y, y > x);
}

[test]
uniform 0 uint64_t2 42000000000 5000000000
draw quad
probe (0, 0) f32(0.0, 1.0, 1.0, 0.0)
uniform 0 uint64_t2 42000000000 42000000000
draw quad
probe (0, 0) f32(0.0, 0.0, 0.0, 0.0)
